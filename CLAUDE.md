# OpenPod — Agent Instructions

Read `docs/Manifesto-v0.6.0.md` before making any architectural decisions. It is the single source of truth.

## Project Overview

OpenPod is a P2P User-to-Agent (U2A) communication protocol. It is a **transport layer only** — it does not invoke LLMs, manage prompts, or execute tools. The Agent Gateway (e.g., OpenClaw) does that. Pod provides encrypted pipes and a UI to view them.

## Repository Structure

```
openpod/
├── Cargo.toml                  # Workspace root
├── proto/
│   └── pod_protocol.proto      # Wire protocol (protobuf) — shared by all crates
├── crates/
│   ├── pod-proto/              # Compiled protobuf types, codec, shared primitives
│   ├── pod-client-core/        # Client transport (WebTransport client, mDNS browser, mTLS)
│   └── pod-agent-core/         # Agent transport (WebTransport server, mDNS advertiser, mTLS)
├── bindings/
│   ├── python/                 # PyO3 bindings for pod-agent-core → PyPI `pod-sdk`
│   └── node/                   # NAPI-RS bindings for pod-agent-core → npm `pod-sdk`
├── app/                        # Flutter client application (uses pod-client-core via flutter_rust_bridge)
└── docs/
    └── Manifesto-v0.6.0.md     # Root architectural directive
```

## Key Architectural Rules

1. **Pod is communication only.** Never add LLM invocation, tool execution, or prompt management code. If you're tempted to, you're crossing the demarcation line.
2. **Protobuf on the wire, JSON inside.** All network frames are protobuf. Semantic payloads inside protobuf are JSON. No custom text formats.
3. **Rust core, FFI out.** All protocol logic, crypto, and networking lives in Rust crates. Language bindings (Python, Node.js, Dart) are thin FFI wrappers — never duplicate protocol logic in binding code.
4. **mTLS via TOFU + SAS.** Identity = Ed25519 keypair, PodId = SHA-256 of public key. No CA infrastructure. See Manifesto §2.7.
5. **Channel C dual-path.** Control signals (brake/interrupt) are sent on both unreliable datagram AND reliable stream. Receiver deduplicates by signal ID. Never send safety-critical signals on unreliable-only.
6. **Atomic media delivery.** Files upload on dedicated per-file QUIC streams (one stream per file, parallel). The Channel A message carries `pending_attachments` count; the SDK buffers it and delivers text + all completed file paths to the Gateway as a single atomic event. The hold is per-message, not per-channel — other text-only messages flow through immediately.
7. **Multi-client ready.** The agent core must key all state by session ID. No global mutable singletons. Connection acceptance is a loop, not a one-shot.
8. **Structured logging everywhere.** Use `tracing` crate. All log entries include `session_id` and `pod_id` as structured fields. Default level: `INFO`. Configurable via `POD_LOG` env var.

## Crate Responsibilities

### `pod-proto`
- Compiled protobuf types (generated by `prost-build` from `proto/pod_protocol.proto`)
- Shared error types and error code constants
- Protocol version constants
- Any codec utilities shared between client and agent

### `pod-client-core`
- WebTransport client (connection initiation over QUIC)
- mDNS service browser (discovers `_openpod._udp.local` agents)
- Client-side mTLS handshake and PodId verification
- Tri-channel session multiplexing
- Pairing flow (client side): QR scan, SAS verification, trust store
- Media upload via background WebTransport streams

### `pod-agent-core`
- WebTransport server (accepts incoming Pod connections)
- mDNS service advertiser (opt-in, broadcasts `_openpod._udp.local`)
- Server-side mTLS handshake and client verification
- Tri-channel session multiplexing
- Pairing flow (agent side): QR display, SAS verification, trust store
- `.pod_cache` session file cache management
- Session lifecycle (init, close, reconnection window)
- Must expose callback/event interfaces for Gateway integration

## Dependency Choices

| Crate | Purpose |
|-------|---------|
| `prost` / `prost-build` | Protobuf serialization & build-time compilation |
| `tokio` | Async runtime (full features) |
| `quinn` or `wtransport` | QUIC / WebTransport |
| `ed25519-dalek` | Ed25519 identity keypair |
| `rcgen` | Self-signed X.509 certificate generation |
| `mdns-sd` | mDNS/DNS-SD discovery and advertising |
| `sha2`, `hmac` | PodId derivation, SAS computation |
| `tracing` / `tracing-subscriber` | Structured logging |

## Code Style

- Rust edition 2024. Use standard `rustfmt` and `clippy`.
- Error handling: use `thiserror` for library errors exposed across crate boundaries. Use `anyhow` only in binaries/tests.
- Async: all I/O is async via `tokio`. Avoid blocking calls in async contexts.
- Tests: unit tests in `#[cfg(test)]` modules within source files. Integration tests in `tests/` directories.
- No `unsafe` unless absolutely required for FFI boundaries, and document why.

## Common Pitfalls

- **mDNS namespace:** Libraries default to `_tcp`. OpenPod uses `_udp`. Always override.
- **Certificate rotation:** The TLS cert rotates every 30 days but the identity key (and PodId) is permanent. Verify PodId, not cert fingerprint.
- **Channel C deduplication:** Control signals carry a unique signal ID. The receiver must deduplicate since the same signal arrives via two paths (datagram + stream).
- **Session reconnection:** On ungraceful disconnect, preserve session state for 5 minutes. Match reconnecting clients by PodId + session_id. QUIC transport ACKs don't survive connection death — use application-layer `seq_id`/`ack_id` in protobuf wrappers and buffer un-ACK'd messages for replay.
- **File stream lifecycle:** One QUIC stream per file upload. Don't reuse a persistent stream for multiple files — you'll get head-of-line blocking and need custom framing. QUIC stream creation is free.
